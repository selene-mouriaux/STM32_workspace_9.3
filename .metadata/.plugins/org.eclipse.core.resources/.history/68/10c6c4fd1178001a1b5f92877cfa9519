/*
 * game_pc4.c
 *
 *  Created on: Mar 30, 2020
 *      Author: s_il_vanas
 */

#include "game_p4.h"
#include<stdint.h>
#include<stdio.h>
#include "debug.h"

static int8_t matrice[MATRIX_HEIGHT][MATRIX_WIDTH] = {{0,1,1,0,0,1,2}, {0,2,1,0,0,2,1}, {0,1,1,0,0,2,1}, {0,2,2,1,0,1,2},
		{0,1,2,2,1,2,1} ,{0,1,2,2,2,1,2}};		// écriture en dur pour tests, ne sera plus initialisée en usage normal

static player_t active_player = NO_PLAYER;	// active player = 0 puis 1 a l'init et alterne de 1 à 2 en jeu
static int8_t token_top_selector = 0;			// token top selector court de 0 à nb de colonnes -1
// static char colorP1[10];
// static char colorP2[10];						// seront définies plus tard en clair dans la limite de 10 chars pour AQUAMARINE


void gp4_init(void) {
	// fn qui initialise la matrice et les variables concernées à un état de début de jeu
	int8_t i;
	int8_t j;
	for ( i = 0 ; i < MATRIX_HEIGHT ; i++ ) {
		for ( j = 0 ; j < MATRIX_WIDTH ; j++ ) {
			matrice[i][j] = 0;
		}
	}
	active_player = PLAYER_1;					// PLAYER_1 SI input via pad 1 OU PLAYER_2 SI input via pad 2;
	//	colorP1 = import SD						// iront se set sur la carte SD avec les choix client
	//	colorP2 = import SD
}


void gp4_display(void) {
	// fn qui affiche l'état de la grille, le tour joueur via le token et son emplacement
	printf("\n\n TOP  =  ");
	for ( int8_t i = 0 ; i < MATRIX_WIDTH ; i++) {
		if ( i == token_top_selector ) {
			printf("%d  ", active_player);
		} else {
			printf("-  ");
		}
	}
	for ( int8_t i = 0 ; i < MATRIX_HEIGHT ; i++) {
		printf("\nLine %d=  ",i+1);
		for ( int8_t j = 0 ; j < MATRIX_WIDTH ; j++) {
			if ( matrice[i][j] == 0 ) {
				printf("-  ");
			} else {
				printf("%d  ", matrice[i][j]);
			}
		}
	}
}


void gp4_set_player(void) {
	if ( active_player == PLAYER_1) {
		active_player = PLAYER_2;
	} else {
		active_player = PLAYER_1;
	}
}


void gp4_top_move_token_left(void) {
	int8_t i;
	for (i=0; i < MATRIX_WIDTH ; i++) {
		if (token_top_selector - 1 >= 0 && matrice[0][token_top_selector - 1] == 0) {
			token_top_selector = token_top_selector - 1;
			i = MATRIX_WIDTH;
		} else if (token_top_selector - 1 >= 0 && matrice[0][token_top_selector - 1] != 0) {
			token_top_selector = token_top_selector - 1;
		} else if (token_top_selector - 1 < 0 && matrice[0][MATRIX_WIDTH - 1] == 0) {
			token_top_selector = MATRIX_WIDTH - 1;
			i = MATRIX_WIDTH;
		} else if (token_top_selector - 1 < 0 && matrice[0][MATRIX_WIDTH - 1] != 0) {
			token_top_selector = MATRIX_WIDTH - 1;
		}
	}
//	if (i == MATRIX_WIDTH -1)
//		is_ok = False;
}


void gp4_top_move_token_right(void) {
	for (int8_t i = 0 ; i < MATRIX_WIDTH ; i++) {
		if (token_top_selector + 1 < MATRIX_WIDTH && matrice[0][token_top_selector + 1] == 0) {
			token_top_selector = token_top_selector + 1;
			i = MATRIX_WIDTH;
		} else if (token_top_selector + 1 < MATRIX_WIDTH && matrice[0][token_top_selector + 1] != 0) {
			token_top_selector = token_top_selector + 1;
		} else if (token_top_selector + 1 >= MATRIX_WIDTH && matrice[0][0] == 0) {
			token_top_selector = 0;
			i = MATRIX_WIDTH;
		} else if (token_top_selector + 1 >= MATRIX_WIDTH && matrice[0][0] != 0) {
			token_top_selector = 0;
		}
	}
	//	if (i == MATRIX_WIDTH -1)
	//		is_ok = False;
}


int8_t gp4_play_token(void) {
	int8_t moveok = 0;
	while (!moveok) {
		int8_t current_play_height;
		for ( current_play_height = 0 ; matrice[current_play_height][token_top_selector] != 0 ; current_play_height++ ) {}
		if ( current_play_height >= 5 ) {
			debug_printf(1, "invalid move");
		} else {

		}
	}
}





